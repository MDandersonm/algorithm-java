package SW_Expert_Academy.p1933간단한N의약수;
//약수구해서 오름차순 정렬 출력
//for문으로 하나하나 구하면 느리다.

import java.util.Scanner;
import java.util.ArrayList;

public class Answer {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int N = sc.nextInt();
        ArrayList<Integer> divisors = new ArrayList<>();

        for (int i = 1; i * i <= N; i++) {
            if (N % i == 0) {
                System.out.print(i + " ");
                if (i != N / i) {  // i와 N/i가 다를 경우에만 추가
                    divisors.add(N / i);
                }
            }
        }
        System.out.println(divisors);
        // 큰 약수부터 출력
        for (int i = divisors.size() - 1; i >= 0; i--) {
            System.out.print(divisors.get(i) + " ");
        }
        sc.close();
    }
}
    /*

 약수는 대칭성을 갖습니다. 예를 들어, 28의 약수는 1, 2, 4, 7, 14, 28입니다. 1과 28, 2와 14, 4와 7이 서로 쌍을 이룹니다. 따라서 우리는

 루트N 까지만 체크하며, 해당 수가 N의 약수라면 해당 수와 N을 해당 수로 나눈 몫 둘 다 약수로 간주할 수 있습니다.

하지만 이렇게 하면 출력 순서가 문제의 요구사항과 일치하지 않을 수 있습니다. 따라서

 까지의 약수를 먼저 출력하고, 그 이후에는 큰 약수부터 출력하면 문제를 효율적으로 해결할 수 있습니다.

이 아이디어를 활용하면 시간 복잡도를 개선할 수 있습니다. */
/*
루트N 까지만 검사하는 이유는 효율성과 관련이 있습니다.

약수는 쌍으로 존재합니다. 예를 들어, 12의 약수는 1, 2, 3, 4, 6, 12입니다. 이때, 1과 12는 쌍을 이룹니다. 왜냐하면
1×12=12이기 때문입니다. 마찬가지로, 2와 6도 쌍을 이룹니다. 2×6=12 이기 때문이죠. 그리고 3과 4도 쌍을 이룹니다.
이렇게 약수는 항상 쌍으로 존재합니다. 그러나, 완전제곱수의 경우에는 중간에 루트 값이 홀로 존재하기 때문에 예외입니다.
예를 들면, 36의 경우 중간에 6이 홀로 존재합니다.따라서, 루트N 까지만 약수를 찾으면, 그 이후의 약수는 이미 앞에서 찾은 약수와 쌍을 이루는 것이므로 다시 찾을 필요가 없습니다.
예를 들어, 36의 경우에 루트 36은 6이므로 6까지만 약수를 찾으면, 1, 2, 3, 4, 6이 됩니다. 6 이후의 약수 9, 12, 18, 36은 각각 4, 3, 2, 1과 쌍을 이룹니다.

이 방법을 사용하면, N 의 모든 약수를 찾기 위해 1부터 N 까지 검사하는 것보다 훨씬 빠르게 약수를 찾을 수 있습니다.
 */

